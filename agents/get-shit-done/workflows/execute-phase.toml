prompt = "<purpose>\nExecute all plans in a phase using wave-based parallel execution. Orchestrator stays lean by delegating plan execution to subagents.\n</purpose>\n\n<core_principle>\nThe orchestrator's job is coordination, not execution. Each subagent loads the full execute-plan context itself. Orchestrator discovers plans, analyzes dependencies, groups into waves, spawns agents, handles checkpoints, collects results.\n</core_principle>\n\n<required_reading>\nRead STATE.md before any operation to load project context.\nRead config.json for planning behavior settings.\n</required_reading>\n\n<process>\n\n<step name=\"resolve_model_profile\" priority=\"first\">\nRead model profile for agent spawning:\n\n```bash\nMODEL_PROFILE=$(cat .planning/config.json 2>/dev/null | grep -o '\"model_profile\"[[:space:]]*:[[:space:]]*\"[^\"]*\"' | grep -o '\"[^\"]*\"$' | tr -d '\"' || echo \"balanced\")\n```\n\nDefault to \"balanced\" if not set.\n\n**Model lookup table:**\n\n| Agent | quality | balanced | budget |\n|-------|---------|----------|--------|\n| gsd-executor | opus | sonnet | sonnet |\n| gsd-verifier | sonnet | sonnet | haiku |\n| general-purpose | — | — | — |\n\nStore resolved models for use in Task calls below.\n</step>\n\n<step name=\"load_project_state\">\nBefore any operation, read project state:\n\n```bash\ncat .planning/STATE.md 2>/dev/null\n```\n\n**If file exists:** Parse and internalize:\n- Current position (phase, plan, status)\n- Accumulated decisions (constraints on this execution)\n- Blockers/concerns (things to watch for)\n\n**If file missing but .planning/ exists:**\n```\nSTATE.md missing but planning artifacts exist.\nOptions:\n1. Reconstruct from existing artifacts\n2. Continue without project state (may lose accumulated context)\n```\n\n**If .planning/ doesn't exist:** Error - project not initialized.\n\n**Load planning config:**\n\n```bash\n# Check if planning docs should be committed (default: true)\nCOMMIT_PLANNING_DOCS=$(cat .planning/config.json 2>/dev/null | grep -o '\"commit_docs\"[[:space:]]*:[[:space:]]*[^,}]*' | grep -o 'true\\|false' || echo \"true\")\n# Auto-detect gitignored (overrides config)\ngit check-ignore -q .planning 2>/dev/null && COMMIT_PLANNING_DOCS=false\n```\n\nStore `COMMIT_PLANNING_DOCS` for use in git operations.\n\n**Load git branching config:**\n\n```bash\n# Get branching strategy (default: none)\nBRANCHING_STRATEGY=$(cat .planning/config.json 2>/dev/null | grep -o '\"branching_strategy\"[[:space:]]*:[[:space:]]*\"[^\"]*\"' | sed 's/.*:.*\"\\([^\"]*\\)\"/\\1/' || echo \"none\")\n\n# Get templates\nPHASE_BRANCH_TEMPLATE=$(cat .planning/config.json 2>/dev/null | grep -o '\"phase_branch_template\"[[:space:]]*:[[:space:]]*\"[^\"]*\"' | sed 's/.*:.*\"\\([^\"]*\\)\"/\\1/' || echo \"gsd/phase-{phase}-{slug}\")\nMILESTONE_BRANCH_TEMPLATE=$(cat .planning/config.json 2>/dev/null | grep -o '\"milestone_branch_template\"[[:space:]]*:[[:space:]]*\"[^\"]*\"' | sed 's/.*:.*\"\\([^\"]*\\)\"/\\1/' || echo \"gsd/{milestone}-{slug}\")\n```\n\nStore `BRANCHING_STRATEGY` and templates for use in branch creation step.\n</step>\n\n<step name=\"handle_branching\">\nCreate or switch to appropriate branch based on branching strategy.\n\n**Skip if strategy is \"none\":**\n\n```bash\nif [ \"$BRANCHING_STRATEGY\" = \"none\" ]; then\n  # No branching, continue on current branch\n  exit 0\nfi\n```\n\n**For \"phase\" strategy — create phase branch:**\n\n```bash\nif [ \"$BRANCHING_STRATEGY\" = \"phase\" ]; then\n  # Get phase name from directory (e.g., \"03-authentication\" → \"authentication\")\n  PHASE_NAME=$(basename \"$PHASE_DIR\" | sed 's/^[0-9]*-//')\n\n  # Create slug from phase name\n  PHASE_SLUG=$(echo \"$PHASE_NAME\" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//;s/-$//')\n\n  # Apply template\n  BRANCH_NAME=$(echo \"$PHASE_BRANCH_TEMPLATE\" | sed \"s/{phase}/$PADDED_PHASE/g\" | sed \"s/{slug}/$PHASE_SLUG/g\")\n\n  # Create or switch to branch\n  git checkout -b \"$BRANCH_NAME\" 2>/dev/null || git checkout \"$BRANCH_NAME\"\n\n  echo \"Branch: $BRANCH_NAME (phase branching)\"\nfi\n```\n\n**For \"milestone\" strategy — create/switch to milestone branch:**\n\n```bash\nif [ \"$BRANCHING_STRATEGY\" = \"milestone\" ]; then\n  # Get current milestone info from ROADMAP.md\n  MILESTONE_VERSION=$(grep -oE 'v[0-9]+\\.[0-9]+' .planning/ROADMAP.md | head -1 || echo \"v1.0\")\n  MILESTONE_NAME=$(grep -A1 \"## .*$MILESTONE_VERSION\" .planning/ROADMAP.md | tail -1 | sed 's/.*- //' | cut -d'(' -f1 | tr -d ' ' || echo \"milestone\")\n\n  # Create slug\n  MILESTONE_SLUG=$(echo \"$MILESTONE_NAME\" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//;s/-$//')\n\n  # Apply template\n  BRANCH_NAME=$(echo \"$MILESTONE_BRANCH_TEMPLATE\" | sed \"s/{milestone}/$MILESTONE_VERSION/g\" | sed \"s/{slug}/$MILESTONE_SLUG/g\")\n\n  # Create or switch to branch (same branch for all phases in milestone)\n  git checkout -b \"$BRANCH_NAME\" 2>/dev/null || git checkout \"$BRANCH_NAME\"\n\n  echo \"Branch: $BRANCH_NAME (milestone branching)\"\nfi\n```\n\n**Report branch status:**\n\n```\nBranching: {strategy} → {branch_name}\n```\n\n**Note:** All subsequent plan commits go to this branch. User handles merging based on their workflow.\n</step>\n\n<step name=\"validate_phase\">\nConfirm phase exists and has plans:\n\n```bash\n# Match both zero-padded (05-*) and unpadded (5-*) folders\nPADDED_PHASE=$(printf \"%02d\" ${PHASE_ARG} 2>/dev/null || echo \"${PHASE_ARG}\")\nPHASE_DIR=$(ls -d .planning/phases/${PADDED_PHASE}-* .planning/phases/${PHASE_ARG}-* 2>/dev/null | head -1)\nif [ -z \"$PHASE_DIR\" ]; then\n  echo \"ERROR: No phase directory matching '${PHASE_ARG}'\"\n  exit 1\nfi\n\nPLAN_COUNT=$(ls -1 \"$PHASE_DIR\"/*-PLAN.md 2>/dev/null | wc -l | tr -d ' ')\nif [ \"$PLAN_COUNT\" -eq 0 ]; then\n  echo \"ERROR: No plans found in $PHASE_DIR\"\n  exit 1\nfi\n```\n\nReport: \"Found {N} plans in {phase_dir}\"\n</step>\n\n<step name=\"discover_plans\">\nList all plans and extract metadata:\n\n```bash\n# Get all plans\nls -1 \"$PHASE_DIR\"/*-PLAN.md 2>/dev/null | sort\n\n# Get completed plans (have SUMMARY.md)\nls -1 \"$PHASE_DIR\"/*-SUMMARY.md 2>/dev/null | sort\n```\n\nFor each plan, read frontmatter to extract:\n- `wave: N` - Execution wave (pre-computed)\n- `autonomous: true/false` - Whether plan has checkpoints\n- `gap_closure: true/false` - Whether plan closes gaps from verification/UAT\n\nBuild plan inventory:\n- Plan path\n- Plan ID (e.g., \"03-01\")\n- Wave number\n- Autonomous flag\n- Gap closure flag\n- Completion status (SUMMARY exists = complete)\n\n**Filtering:**\n- Skip completed plans (have SUMMARY.md)\n- If `--gaps-only` flag: also skip plans where `gap_closure` is not `true`\n\nIf all plans filtered out, report \"No matching incomplete plans\" and exit.\n</step>\n\n<step name=\"group_by_wave\">\nRead `wave` from each plan's frontmatter and group by wave number:\n\n```bash\n# For each plan, extract wave from frontmatter\nfor plan in $PHASE_DIR/*-PLAN.md; do\n  wave=$(grep \"^wave:\" \"$plan\" | cut -d: -f2 | tr -d ' ')\n  autonomous=$(grep \"^autonomous:\" \"$plan\" | cut -d: -f2 | tr -d ' ')\n  echo \"$plan:$wave:$autonomous\"\ndone\n```\n\n**Group plans:**\n```\nwaves = {\n  1: [plan-01, plan-02],\n  2: [plan-03, plan-04],\n  3: [plan-05]\n}\n```\n\n**No dependency analysis needed.** Wave numbers are pre-computed during `/gsd:plan-phase`.\n\nReport wave structure with context:\n```\n## Execution Plan\n\n**Phase {X}: {Name}** — {total_plans} plans across {wave_count} waves\n\n| Wave | Plans | What it builds |\n|------|-------|----------------|\n| 1 | 01-01, 01-02 | {from plan objectives} |\n| 2 | 01-03 | {from plan objectives} |\n| 3 | 01-04 [checkpoint] | {from plan objectives} |\n\n```\n\nThe \"What it builds\" column comes from skimming plan names/objectives. Keep it brief (3-8 words).\n</step>\n\n<step name=\"execute_waves\">\nExecute each wave in sequence. Autonomous plans within a wave run in parallel.\n\n**For each wave:**\n\n1. **Describe what's being built (BEFORE spawning):**\n\n   Read each plan's `<objective>` section. Extract what's being built and why it matters.\n\n   **Output:**\n   ```\n   ---\n\n   ## Wave {N}\n\n   **{Plan ID}: {Plan Name}**\n   {2-3 sentences: what this builds, key technical approach, why it matters in context}\n\n   **{Plan ID}: {Plan Name}** (if parallel)\n   {same format}\n\n   Spawning {count} agent(s)...\n\n   ---\n   ```\n\n   **Examples:**\n   - Bad: \"Executing terrain generation plan\"\n   - Good: \"Procedural terrain generator using Perlin noise — creates height maps, biome zones, and collision meshes. Required before vehicle physics can interact with ground.\"\n\n2. **Read files and spawn all autonomous agents in wave simultaneously:**\n\n   Before spawning, read file contents. The `@` syntax does not work across Task() boundaries - content must be inlined.\n\n   ```bash\n   # Read each plan in the wave\n   PLAN_CONTENT=$(cat \"{plan_path}\")\n   STATE_CONTENT=$(cat .planning/STATE.md)\n   CONFIG_CONTENT=$(cat .planning/config.json 2>/dev/null)\n   ```\n\n   Use Task tool with multiple parallel calls. Each agent gets prompt with inlined content:\n\n   ```\n   <objective>\n   Execute plan {plan_number} of phase {phase_number}-{phase_name}.\n\n   Commit each task atomically. Create SUMMARY.md. Update STATE.md.\n   </objective>\n\n   <execution_context>\n   @/Users/filipefernandes/.gemini/get-shit-done/workflows/execute-plan.md\n   @/Users/filipefernandes/.gemini/get-shit-done/templates/summary.md\n   @/Users/filipefernandes/.gemini/get-shit-done/references/checkpoints.md\n   @/Users/filipefernandes/.gemini/get-shit-done/references/tdd.md\n   </execution_context>\n\n   <context>\n   Plan:\n   {plan_content}\n\n   Project state:\n   {state_content}\n\n   Config (if exists):\n   {config_content}\n   </context>\n\n   <success_criteria>\n   - [ ] All tasks executed\n   - [ ] Each task committed individually\n   - [ ] SUMMARY.md created in plan directory\n   - [ ] STATE.md updated with position and decisions\n   </success_criteria>\n   ```\n\n2. **Wait for all agents in wave to complete:**\n\n   Task tool blocks until each agent finishes. All parallel agents return together.\n\n3. **Report completion and what was built:**\n\n   For each completed agent:\n   - Verify SUMMARY.md exists at expected path\n   - Read SUMMARY.md to extract what was built\n   - Note any issues or deviations\n\n   **Output:**\n   ```\n   ---\n\n   ## Wave {N} Complete\n\n   **{Plan ID}: {Plan Name}**\n   {What was built — from SUMMARY.md deliverables}\n   {Notable deviations or discoveries, if any}\n\n   **{Plan ID}: {Plan Name}** (if parallel)\n   {same format}\n\n   {If more waves: brief note on what this enables for next wave}\n\n   ---\n   ```\n\n   **Examples:**\n   - Bad: \"Wave 2 complete. Proceeding to Wave 3.\"\n   - Good: \"Terrain system complete — 3 biome types, height-based texturing, physics collision meshes. Vehicle physics (Wave 3) can now reference ground surfaces.\"\n\n4. **Handle failures:**\n\n   If any agent in wave fails:\n   - Report which plan failed and why\n   - Ask user: \"Continue with remaining waves?\" or \"Stop execution?\"\n   - If continue: proceed to next wave (dependent plans may also fail)\n   - If stop: exit with partial completion report\n\n5. **Execute checkpoint plans between waves:**\n\n   See `<checkpoint_handling>` for details.\n\n6. **Proceed to next wave**\n\n</step>\n\n<step name=\"checkpoint_handling\">\nPlans with `autonomous: false` require user interaction.\n\n**Detection:** Check `autonomous` field in frontmatter.\n\n**Execution flow for checkpoint plans:**\n\n1. **Spawn agent for checkpoint plan:**\n   ```\n   Task(prompt=\"{subagent-task-prompt}\", subagent_type=\"gsd-executor\", model=\"{executor_model}\")\n   ```\n\n2. **Agent runs until checkpoint:**\n   - Executes auto tasks normally\n   - Reaches checkpoint task (e.g., `type=\"checkpoint:human-verify\"`) or auth gate\n   - Agent returns with structured checkpoint (see checkpoint-return.md template)\n\n3. **Agent return includes (structured format):**\n   - Completed Tasks table with commit hashes and files\n   - Current task name and blocker\n   - Checkpoint type and details for user\n   - What's awaited from user\n\n4. **Orchestrator presents checkpoint to user:**\n\n   Extract and display the \"Checkpoint Details\" and \"Awaiting\" sections from agent return:\n   ```\n   ## Checkpoint: [Type]\n\n   **Plan:** 03-03 Dashboard Layout\n   **Progress:** 2/3 tasks complete\n\n   [Checkpoint Details section from agent return]\n\n   [Awaiting section from agent return]\n   ```\n\n5. **User responds:**\n   - \"approved\" / \"done\" → spawn continuation agent\n   - Description of issues → spawn continuation agent with feedback\n   - Decision selection → spawn continuation agent with choice\n\n6. **Spawn continuation agent (NOT resume):**\n\n   Use the continuation-prompt.md template:\n   ```\n   Task(\n     prompt=filled_continuation_template,\n     subagent_type=\"gsd-executor\",\n     model=\"{executor_model}\"\n   )\n   ```\n\n   Fill template with:\n   - `{completed_tasks_table}`: From agent's checkpoint return\n   - `{resume_task_number}`: Current task from checkpoint\n   - `{resume_task_name}`: Current task name from checkpoint\n   - `{user_response}`: What user provided\n   - `{resume_instructions}`: Based on checkpoint type (see continuation-prompt.md)\n\n7. **Continuation agent executes:**\n   - Verifies previous commits exist\n   - Continues from resume point\n   - May hit another checkpoint (repeat from step 4)\n   - Or completes plan\n\n8. **Repeat until plan completes or user stops**\n\n**Why fresh agent instead of resume:**\nResume relies on Claude Code's internal serialization which breaks with parallel tool calls.\nFresh agents with explicit state are more reliable and maintain full context.\n\n**Checkpoint in parallel context:**\nIf a plan in a parallel wave has a checkpoint:\n- Spawn as normal\n- Agent pauses at checkpoint and returns with structured state\n- Other parallel agents may complete while waiting\n- Present checkpoint to user\n- Spawn continuation agent with user response\n- Wait for all agents to finish before next wave\n</step>\n\n<step name=\"aggregate_results\">\nAfter all waves complete, aggregate results:\n\n```markdown\n## Phase {X}: {Name} Execution Complete\n\n**Waves executed:** {N}\n**Plans completed:** {M} of {total}\n\n### Wave Summary\n\n| Wave | Plans | Status |\n|------|-------|--------|\n| 1 | plan-01, plan-02 | ✓ Complete |\n| CP | plan-03 | ✓ Verified |\n| 2 | plan-04 | ✓ Complete |\n| 3 | plan-05 | ✓ Complete |\n\n### Plan Details\n\n1. **03-01**: [one-liner from SUMMARY.md]\n2. **03-02**: [one-liner from SUMMARY.md]\n...\n\n### Issues Encountered\n[Aggregate from all SUMMARYs, or \"None\"]\n```\n</step>\n\n<step name=\"verify_phase_goal\">\nVerify phase achieved its GOAL, not just completed its TASKS.\n\n**Spawn verifier:**\n\n```\nTask(\n  prompt=\"Verify phase {phase_number} goal achievement.\n\nPhase directory: {phase_dir}\nPhase goal: {goal from ROADMAP.md}\n\nCheck must_haves against actual codebase. Create VERIFICATION.md.\nVerify what actually exists in the code.\",\n  subagent_type=\"gsd-verifier\",\n  model=\"{verifier_model}\"\n)\n```\n\n**Read verification status:**\n\n```bash\ngrep \"^status:\" \"$PHASE_DIR\"/*-VERIFICATION.md | cut -d: -f2 | tr -d ' '\n```\n\n**Route by status:**\n\n| Status | Action |\n|--------|--------|\n| `passed` | Continue to update_roadmap |\n| `human_needed` | Present items to user, get approval or feedback |\n| `gaps_found` | Present gap summary, offer `/gsd:plan-phase {phase} --gaps` |\n\n**If passed:**\n\nPhase goal verified. Proceed to update_roadmap.\n\n**If human_needed:**\n\n```markdown\n## ✓ Phase {X}: {Name} — Human Verification Required\n\nAll automated checks passed. {N} items need human testing:\n\n### Human Verification Checklist\n\n{Extract from VERIFICATION.md human_verification section}\n\n---\n\n**After testing:**\n- \"approved\" → continue to update_roadmap\n- Report issues → will route to gap closure planning\n```\n\nIf user approves → continue to update_roadmap.\nIf user reports issues → treat as gaps_found.\n\n**If gaps_found:**\n\nPresent gaps and offer next command:\n\n```markdown\n## ⚠ Phase {X}: {Name} — Gaps Found\n\n**Score:** {N}/{M} must-haves verified\n**Report:** {phase_dir}/{phase}-VERIFICATION.md\n\n### What's Missing\n\n{Extract gap summaries from VERIFICATION.md gaps section}\n\n---\n\n## ▶ Next Up\n\n**Plan gap closure** — create additional plans to complete the phase\n\n`/gsd:plan-phase {X} --gaps`\n\n*(`/clear` first → fresh context window)*\n\n---\n\n**Also available:**\n- `cat {phase_dir}/{phase}-VERIFICATION.md` — see full report\n- `/gsd:verify-work {X}` — manual testing before planning\n```\n\nUser runs `/gsd:plan-phase {X} --gaps` which:\n1. Reads VERIFICATION.md gaps\n2. Creates additional plans (04, 05, etc.) with `gap_closure: true` to close gaps\n3. User then runs `/gsd:execute-phase {X} --gaps-only`\n4. Execute-phase runs only gap closure plans (04-05)\n5. Verifier runs again after new plans complete\n\nUser stays in control at each decision point.\n</step>\n\n<step name=\"update_roadmap\">\nUpdate ROADMAP.md to reflect phase completion:\n\n```bash\n# Mark phase complete\n# Update completion date\n# Update status\n```\n\n**Check planning config:**\n\nIf `COMMIT_PLANNING_DOCS=false` (set in load_project_state):\n- Skip all git operations for .planning/ files\n- Planning docs exist locally but are gitignored\n- Log: \"Skipping planning docs commit (commit_docs: false)\"\n- Proceed to offer_next step\n\nIf `COMMIT_PLANNING_DOCS=true` (default):\n- Continue with git operations below\n\nCommit phase completion (roadmap, state, verification):\n```bash\ngit add .planning/ROADMAP.md .planning/STATE.md .planning/phases/{phase_dir}/*-VERIFICATION.md\ngit add .planning/REQUIREMENTS.md  # if updated\ngit commit -m \"docs(phase-{X}): complete phase execution\"\n```\n</step>\n\n<step name=\"offer_next\">\nPresent next steps based on milestone status:\n\n**If more phases remain:**\n```\n## Next Up\n\n**Phase {X+1}: {Name}** — {Goal}\n\n`/gsd:plan-phase {X+1}`\n\n*(`/clear` first for fresh context)*\n```\n\n**If milestone complete:**\n```\nMILESTONE COMPLETE!\n\nAll {N} phases executed.\n\n`/gsd:complete-milestone`\n```\n</step>\n\n</process>\n\n<context_efficiency>\nOrchestrator: ~10-15% context (frontmatter, spawning, results).\nSubagents: Fresh 200k each (full workflow + execution).\nNo polling (Task blocks). No context bleed.\n</context_efficiency>\n\n<failure_handling>\n**Subagent fails mid-plan:**\n- SUMMARY.md won't exist\n- Orchestrator detects missing SUMMARY\n- Reports failure, asks user how to proceed\n\n**Dependency chain breaks:**\n- Wave 1 plan fails\n- Wave 2 plans depending on it will likely fail\n- Orchestrator can still attempt them (user choice)\n- Or skip dependent plans entirely\n\n**All agents in wave fail:**\n- Something systemic (git issues, permissions, etc.)\n- Stop execution\n- Report for manual investigation\n\n**Checkpoint fails to resolve:**\n- User can't approve or provides repeated issues\n- Ask: \"Skip this plan?\" or \"Abort phase execution?\"\n- Record partial progress in STATE.md\n</failure_handling>\n\n<resumption>\n**Resuming interrupted execution:**\n\nIf phase execution was interrupted (context limit, user exit, error):\n\n1. Run `/gsd:execute-phase {phase}` again\n2. discover_plans finds completed SUMMARYs\n3. Skips completed plans\n4. Resumes from first incomplete plan\n5. Continues wave-based execution\n\n**STATE.md tracks:**\n- Last completed plan\n- Current wave\n- Any pending checkpoints\n</resumption>\n"
